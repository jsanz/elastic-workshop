<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" sizes="32x32" href="https://www.elastic.co/favicon-32x32.png">

    <script src='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css' rel='stylesheet' />

    <title>ES geospatial data viewer: Hexagonal Grid Aggregation</title>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Helvetica Neue, Arial, Helvetica, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        #info {
            display: table;
            position: relative;
            margin: 10px auto 0 10px;
            word-wrap: anywhere;
            padding: 10px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            text-align: center;
            color: #222;
            background: #fff;
            border: 2px solid darkslateblue;
        }

        #info h3,
        #info p {
            margin: 0 0 5px 0;
        }
    </style>
</head>

<body>
    <div id='map'></div>
    <div id="info">
        <h3>311 noise claims<br/> between 2015 and 2020</h3>
        <p>Click on a hex to get the count</p>
        <p>Count: <strong><span id="count"></span></strong></p>
    </div>
    <script>
        /* Basemap style provided by Maptiler */
        const MAP_STYLE = 'https://api.maptiler.com/maps/dataviz/style.json?key=LqOKqjXlNHCUvaHo6msW';
        /* ES instance with geodata and anonymous access enabled */
        const ES_HOST = 'https://jorge-sanz.es.eastus2.azure.elastic-cloud.com';

        /* ES index and geometry field */
        const ES_INDEX = '311';
        const ES_FIELD = 'location';

        /* VT request */
        const ES_TILES = `${ES_HOST}/${ES_INDEX}/_mvt/${ES_FIELD}/{z}/{x}/{y}`;

        /* VT query for hits */
        const ES_SEARCH_BODY = {
            size: 0,
            grid_precision: 5,
            exact_bounds: false,
            extent: 4096,
            grid_agg: "geohex",
            grid_type: "grid",
            with_labels: true,
            fields: [
                "Complaint Type",
                "Agency Name",
                "Closed Date",
                "Incident Address",
                "Location Type",
                "Resolution Description",
                "Status"
            ],
            query: {
                "bool": {
                    "filter": [
                        {
                            "range": {
                                "Created Date": {
                                    "gte": "2015-01-01",
                                    "lte": "2021-01-01"
                                }
                            }
                        },
                        {
                            "terms": {
                                "Complaint Type": [
                                    "Noise - Residential",
                                    "Noise - Street/sidewalk",
                                    "Noise - Vehicle",
                                    "Noise - Commercial",
                                    "Noise - Helicopter",
                                    "Noise - Park",
                                    "Noise"
                                ]
                            }
                        }
                    ]
                }
            }
        };
        const INITIAL_ZOOM = 10;
        const MIN_ZOOM = 8;
        const MAX_ZOOM = 14;
        const COUNTS_PER_ZOOM = [
            500000,500000,500000,500000,500000,500000, //0 - 5
            500000,500000,500000,85000,30000, 30000, 7000, // 6 - 12
            2000, 1000, 500, 500 // 13 - 14
        ]

        const map = new maplibregl.Map({
            container: 'map',
            style: MAP_STYLE,
            center: [-73.95, 40.7],
            zoom: INITIAL_ZOOM,
            minZoom: MIN_ZOOM,
            maxZoom: MAX_ZOOM,
            hash: true,
            transformRequest: function (url, resourceType) {
                /* This function enriches the HTTP request to include
                the ES search body, change to a POST request, and include
                the Content-Type header */
                if (resourceType == 'Tile' && url.startsWith(ES_HOST)) {
                    return {
                        url: url,
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        type: 'arrayBuffer',
                        body: JSON.stringify(ES_SEARCH_BODY)
                    }
                }
            }
        });

        const getFillColor = function (zoom) {
            const intZoom = parseInt(zoom);
            
            return [
                'interpolate',
                ['linear'],
                ['get', '_count'],
                0, ['to-color', 'white'],
                COUNTS_PER_ZOOM[intZoom], ['to-color', 'red']
            ];
        }

        map.addControl(new maplibregl.NavigationControl());

        map.on('load', function () {
            /* Source for ES data */
            map.addSource('ES', {
                'type': 'vector',
                'tiles': [ES_TILES],
                'minzoom': 0,
                'maxzoom': MAX_ZOOM,
                'attribution': '<a href=Â¨"https://elastic.co">Elasticsearch data</a>'
            });

            map.addLayer(
                {
                    'id': 'data',
                    'type': 'fill',
                    'source': 'ES',
                    'source-layer': 'aggs',
                    'paint': {
                        'fill-opacity': 0.8,
                        'fill-color': getFillColor(INITIAL_ZOOM)
                    }
                }
            );
            map.addLayer(
                {
                    'id': 'border-data',
                    'type': 'line',
                    'source': 'ES',
                    'source-layer': 'aggs',
                    'paint': {
                        'line-color': '#ccc',
                        'line-width': 1.5
                    }
                }
            );
        });


        const updatePalette = function () {
            map.setPaintProperty(
                'data', 
                'fill-color',
                getFillColor(map.getZoom()));
        }

        map.on('zoomend', updatePalette);


        /* A very simple pop up implementation */

        // Create a popup, but don't add it to the map yet.
        var popup = new maplibregl.Popup({
        closeButton: false,
        closeOnClick: false
        });

        /* change cursor on hover */
        map.on('mouseenter', 'data', function (e) { 
            map.getCanvas().style.cursor = 'pointer';
            const feature = e.features[0];

            var coordinates = e.lngLat;
            var description = `<p>${feature.properties._count}</p>`;

            popup.setLngLat(coordinates)
                .setHTML(description)
                .addTo(map);
        });

        /* reset cursor when leaving a feature */
        map.on('mouseleave', 'data', function () { 
            map.getCanvas().style.cursor = ''; 
            popup.remove();
        });

        /* Adding a count based entirely on client features */
        map.on('data', counts);
        map.on('moveend', counts);

        const intFormatter = new Intl.NumberFormat('en-US', { maximumSignificantDigits: 3 });
        function counts() {
            const features = map.queryRenderedFeatures()
            const countEl = document.getElementById('count');
            const preCount = countEl.textContent;
            // Features can be single documents or aggregated hex or grid
            const count = features
                .filter(f => f?.layer?.id == 'data')
                .reduce((acc, cur) => acc + cur.properties._count, 0) / 2;

            if (!count) return;

            // Render the count
            const formattedCount = intFormatter.format(count);
            if (preCount != formattedCount) {
                countEl.textContent = formattedCount;
            }
        };
    </script>
</body>

</html>