---
layout: map.njk
title: Rendering tiles
permalink: tiles.html
---

<div id='map'></div>
<div id="info">
    <h3>311 noise claims<br /> between 2015 and 2020</h3>
    <p>Click on a hex to get the count</p>
    <p>Count: <strong><span id="count"></span></strong></p>
</div>
<script>
    /* ES index and geometry field */
    const ES_INDEX = '311';
    const ES_FIELD = 'location';

    /* VT request */
    const ES_TILES = `${ES_HOST}/${ES_INDEX}/_mvt/${ES_FIELD}/{z}/{x}/{y}`;

    /* VT query for hits */
    const ES_SEARCH_BODY = {
        size: 0,
        grid_precision: 5,
        exact_bounds: false,
        extent: 4096,
        grid_agg: "geotile",
        grid_type: "grid",
        with_labels: true,
        fields: [
            "Complaint Type",
            "Agency Name",
            "Closed Date",
            "Incident Address",
            "Location Type",
            "Resolution Description",
            "Status"
        ],
        query: {
            "bool": {
                "filter": [
                    {
                        "range": {
                            "Created Date": {
                                "gte": "2015-01-01",
                                "lte": "2021-01-01"
                            }
                        }
                    },
                    {
                        "terms": {
                            "Complaint Type": [
                                "Noise - Residential",
                                "Noise - Street/sidewalk",
                                "Noise - Vehicle",
                                "Noise - Commercial",
                                "Noise - Helicopter",
                                "Noise - Park",
                                "Noise"
                            ]
                        }
                    }
                ]
            }
        }
    };
    const INITIAL_ZOOM = 10;
    const MIN_ZOOM = 8;
    const MAX_ZOOM = 14;
    const intFormatter = new Intl.NumberFormat('en-US', { maximumSignificantDigits: 3 });


    const map = new maplibregl.Map({
        container: 'map',
        style: MAP_STYLE,
        center: [-73.95, 40.7],
        zoom: INITIAL_ZOOM,
        minZoom: MIN_ZOOM,
        maxZoom: MAX_ZOOM,
        hash: true,
        transformRequest: function (url, resourceType) {
            /* This function enriches the HTTP request to include
            the ES search body, change to a POST request, and include
            the Content-Type header */
            if (resourceType == 'Tile' && url.startsWith(ES_HOST)) {
                return {
                    url: url,
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    type: 'arrayBuffer',
                    body: JSON.stringify(ES_SEARCH_BODY)
                }
            }
        }
    });

    const getFillColor = function () {
        let max;
        if (map.getLayer('data')) {
            const features = map.queryRenderedFeatures({ 'layers': ['data'] });
            max = Math.max(...features .map(f => f.properties._count));
            console.log('Max value from tiles: ' + max);
        } else {
            console.error("Can't set up a value for the max");
        }

        return [
            'interpolate',
            ['linear'],
            ['get', '_count'],
            0, ['to-color', 'white'],
            max, ['to-color', 'red']
        ];
    }

    map.addControl(new maplibregl.NavigationControl());

    map.on('load', function () {
        /* Source for ES data */
        map.addSource('ES', {
            'type': 'vector',
            'tiles': [ES_TILES],
            'minzoom': 0,
            'maxzoom': MAX_ZOOM,
            'attribution': '<a href=Â¨"https://elastic.co">Elasticsearch data</a>'
        });

        map.addLayer(
            {
                'id': 'data',
                'type': 'fill',
                'source': 'ES',
                'source-layer': 'aggs',
                'paint': {
                    'fill-opacity': 0.8,
                    'fill-color': [
                        'interpolate',
                        ['linear'],
                        ['get', '_count'],
                        0, ['to-color', 'white'],
                        10000, ['to-color', 'red']
                    ]
                }
            }
        );
        map.addLayer(
            {
                'id': 'border-data',
                'type': 'line',
                'source': 'ES',
                'source-layer': 'aggs',
                'paint': {
                    'line-color': '#ccc',
                    'line-width': 1.5
                }
            }
        );
    });


    const updatePalette = function () {
        console.log("Updating the palette")
        map.setPaintProperty(
            'data',
            'fill-color',
            getFillColor());
    }

    map.on('zoomend', updatePalette);


    /* A very simple pop up implementation */

    // Create a popup, but don't add it to the map yet.
    var popup = new maplibregl.Popup({
        closeButton: false,
        closeOnClick: false
    });

    /* change cursor on hover */
    map.on('mousemove', 'data', function (e) {
        const feature = e.features[0];
        if (!feature) { return; }

        map.getCanvas().style.cursor = 'pointer';
        var coordinates = e.lngLat;
        var description = `<p>${intFormatter.format(feature.properties._count)}</p>`;

        popup.setLngLat(coordinates)
            .setHTML(description)
            .addTo(map);
    });

    /* reset cursor when leaving a feature */
    map.on('mouseleave', 'data', function () {
        map.getCanvas().style.cursor = '';
        popup.remove();
    });

    /* Adding a count based entirely on client features */
    map.on('data', counts);
    map.on('moveend', counts);

    function counts() {
        const features = map.queryRenderedFeatures()
        const countEl = document.getElementById('count');
        const preCount = countEl.textContent;
        // Features can be single documents or aggregated hex or grid
        const count = features
            .filter(f => f?.layer?.id == 'data')
            .reduce((acc, cur) => acc + cur.properties._count, 0) / 2;

        if (!count) return;

        // Render the count
        const formattedCount = intFormatter.format(count);
        if (preCount != formattedCount) {
            countEl.textContent = formattedCount;
        }
    };
</script>